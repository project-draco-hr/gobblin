{
  try (Connection conn=createConnection()){
    JobCommitPolicy jobCommitPolicy=JobCommitPolicy.getCommitPolicy(state);
    boolean isSkipStaging=!JobCommitPolicy.COMMIT_ON_FULL_SUCCESS.equals(JobCommitPolicy.getCommitPolicy(state));
    if (isSkipStaging) {
      LOG.info("Writer will write directly to destination table as JobCommitPolicy is " + jobCommitPolicy);
    }
    int branches=state.getPropAsInt(ConfigurationKeys.FORK_BRANCHES_KEY,1);
    Queue<String> stagingTables=new LinkedList<>();
    final String publishTable=getProp(state,ConfigurationKeys.JDBC_PUBLISHER_FINAL_TABLE_NAME,branches,branchId);
    for (int i=0; i < workUnits.size(); i++) {
      if (isSkipStaging) {
        LOG.info("User chose to skip staing table on branch " + branchId);
        stagingTables.add(publishTable);
        if (getPropAsBoolean(state,ConfigurationKeys.JDBC_PUBLISHER_REPLACE_FINAL_TABLE,branches,branchId)) {
          LOG.info("User chose to replace final table " + publishTable + " on branch "+ branchId);
          commands.truncate(conn,publishTable);
        }
        continue;
      }
      String stagingTableKey=ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.WRITER_STAGING_TABLE,branches,branchId);
      String stagingTable=state.getProp(stagingTableKey);
      if (!StringUtils.isEmpty(stagingTable)) {
        LOG.info("Staging table for branch " + branchId + " from user: "+ stagingTable);
        if (!commands.isEmpty(conn,stagingTable)) {
          LOG.error("Staging table " + stagingTable + " is not empty. Failing.");
          throw new IllegalArgumentException("Staging table " + stagingTable + " should be empty.");
        }
        stagingTables.add(stagingTable);
        userCreatedStagingTable=stagingTable;
        continue;
      }
      LOG.info("Staging table has not been passed from user for branch " + branchId + ". Creating.");
      stagingTable=createStagingTable(conn);
      stagingTables.add(stagingTable);
      createdStagingTable=stagingTable;
      LOG.info("Staging table " + stagingTable + " has been created for branchId "+ branchId);
    }
    for (    WorkUnit wu : workUnits) {
      String stagingTable=stagingTables.remove();
      String stagingTableKey=ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.WRITER_STAGING_TABLE,branches,branchId);
      LOG.info("Update workunit state " + stagingTableKey + " , "+ stagingTable);
      wu.setProp(stagingTableKey,stagingTable);
    }
  }
 catch (  SQLException e) {
    throw new RuntimeException("Failed with SQL",e);
  }
}
