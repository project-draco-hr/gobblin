{
  if (workUnits.isEmpty()) {
    LOGGER.warn("No work units to run");
    return;
  }
  for (  WorkUnit workUnit : workUnits) {
    String taskId=workUnit.getProp(ConfigurationKeys.TASK_ID_KEY);
    if (this.taskStateStore.exists(this.jobId,taskId + AbstractJobLauncher.TASK_STATE_STORE_TABLE_SUFFIX)) {
      this.taskStateStore.delete(this.jobId,taskId + AbstractJobLauncher.TASK_STATE_STORE_TABLE_SUFFIX);
    }
  }
  CountDownLatch countDownLatch=new CountDownLatch(workUnits.size());
  List<gobblin.runtime.Task> tasks=AbstractJobLauncher.submitWorkUnits(this.jobId,workUnits,this.taskStateTracker,this.taskExecutor,countDownLatch);
  LOGGER.info(String.format("Waiting for submitted tasks of job %s to complete...",this.jobId));
  while (countDownLatch.getCount() > 0) {
    LOGGER.info(String.format("%d out of %d tasks of job %s are running",countDownLatch.getCount(),workUnits.size(),this.jobId));
    if (countDownLatch.await(10,TimeUnit.SECONDS)) {
      break;
    }
  }
  LOGGER.info(String.format("All assigned tasks of job %s have completed",this.jobId));
  boolean hasTaskFailure=false;
  for (  gobblin.runtime.Task task : tasks) {
    LOGGER.info("Writing task state for task " + task.getTaskId());
    this.taskStateStore.put(task.getJobId(),task.getTaskId() + AbstractJobLauncher.TASK_STATE_STORE_TABLE_SUFFIX,task.getTaskState());
    if (task.getTaskState().getWorkingState() == WorkUnitState.WorkingState.FAILED) {
      hasTaskFailure=true;
    }
  }
  if (hasTaskFailure) {
    for (    gobblin.runtime.Task task : tasks) {
      if (task.getTaskState().contains(ConfigurationKeys.TASK_FAILURE_EXCEPTION_KEY)) {
        LOGGER.error(String.format("Task %s failed due to exception: %s",task.getTaskId(),task.getTaskState().getProp(ConfigurationKeys.TASK_FAILURE_EXCEPTION_KEY)));
      }
    }
    throw new IOException("Not all tasks completed successfully");
  }
}
