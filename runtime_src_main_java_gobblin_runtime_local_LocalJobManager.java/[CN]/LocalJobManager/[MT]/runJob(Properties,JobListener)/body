{
  Preconditions.checkNotNull(jobProps);
  String jobName=jobProps.getProperty(ConfigurationKeys.JOB_NAME_KEY);
  if (jobListener != null) {
    this.jobListenerMap.put(jobName,jobListener);
  }
  if (!acquireJobLock(jobName)) {
    LOG.info(String.format("Previous instance of job %s is still running, skipping this scheduled run",jobName));
    return;
  }
  boolean runOnce=Boolean.valueOf(jobProps.getProperty(ConfigurationKeys.JOB_RUN_ONCE_KEY,"false"));
  String jobId=JobLauncherUtils.newJobId(jobName);
  JobState jobState=new JobState(jobName,jobId);
  jobState.addAll(jobProps);
  jobState.setState(JobState.RunningState.PENDING);
  LOG.info("Starting job " + jobId);
  Optional<SourceState> sourceStateOptional=Optional.absent();
  try {
    SourceState sourceState=new SourceState(jobState,getPreviousWorkUnitStates(jobName));
    Source<?,?> sourceInstance=(Source<?,?>)Class.forName(jobProps.getProperty(ConfigurationKeys.SOURCE_CLASS_KEY)).newInstance();
    Source<?,?> source=new SourceDecorator(sourceInstance,jobId,LOG);
    sourceStateOptional=Optional.of(sourceState);
    Optional<List<WorkUnit>> workUnits=Optional.fromNullable(source.getWorkunits(sourceState));
    if (!workUnits.isPresent()) {
      source.shutdown(sourceState);
      unlockJob(jobName,runOnce);
      throw new JobException("Failed to get work units for job " + jobId);
    }
    if (workUnits.get().isEmpty()) {
      LOG.warn("No work units have been created for job " + jobId);
      source.shutdown(sourceState);
      unlockJob(jobName,runOnce);
      callJobListener(jobName,jobState,runOnce);
      return;
    }
    jobState.setTasks(workUnits.get().size());
    jobState.setStartTime(System.currentTimeMillis());
    jobState.setState(JobState.RunningState.RUNNING);
    this.jobStateMap.put(jobId,jobState);
    this.jobSourceMap.put(jobId,source);
    int sequence=0;
    for (    WorkUnit workUnit : workUnits.get()) {
      String taskId=JobLauncherUtils.newTaskId(jobId,sequence++);
      workUnit.setId(taskId);
      WorkUnitState workUnitState=new WorkUnitState(workUnit);
      workUnitState.setId(taskId);
      workUnitState.setProp(ConfigurationKeys.JOB_ID_KEY,jobId);
      workUnitState.setProp(ConfigurationKeys.TASK_ID_KEY,taskId);
      this.workUnitManager.addWorkUnit(workUnitState);
    }
  }
 catch (  Throwable t) {
    String errMsg="Failed to run job " + jobId;
    LOG.error(errMsg,t);
    if (this.jobSourceMap.containsKey(jobId) && sourceStateOptional.isPresent()) {
      this.jobSourceMap.remove(jobId).shutdown(sourceStateOptional.get());
    }
    this.jobStateMap.remove(jobId);
    unlockJob(jobName,runOnce);
    throw new JobException(errMsg,t);
  }
}
