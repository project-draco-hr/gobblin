{
  Optional<Timer.Context> workUnitsPreparationTimer=Instrumented.timerContext(this.runtimeMetricContext,MetricNames.RunJobTimings.WORK_UNITS_PREPARATION);
  List<WorkUnit> workUnitsToRun=JobLauncherUtils.flattenWorkUnits(workUnits);
  Instrumented.endTimer(workUnitsPreparationTimer);
  if (workUnitsToRun.isEmpty()) {
    LOG.warn("No work units to run");
    return;
  }
  String jobId=this.jobContext.getJobId();
  JobState jobState=this.jobContext.getJobState();
  Optional<Timer.Context> workUnitsRunTimer=Instrumented.timerContext(this.runtimeMetricContext,MetricNames.RunJobTimings.WORK_UNITS_RUN);
  this.countDownLatch=new CountDownLatch(workUnitsToRun.size());
  List<Task> tasks=AbstractJobLauncher.submitWorkUnits(this.jobContext.getJobId(),workUnitsToRun,this.taskStateTracker,this.taskExecutor,this.countDownLatch);
  LOG.info(String.format("Waiting for submitted tasks of job %s to complete...",jobId));
  while (this.countDownLatch.getCount() > 0) {
    LOG.info(String.format("%d out of %d tasks of job %s are running",this.countDownLatch.getCount(),workUnits.size(),jobId));
    this.countDownLatch.await(1,TimeUnit.MINUTES);
  }
  Instrumented.endTimer(workUnitsRunTimer);
  if (this.cancellationRequested) {
synchronized (this.cancellationExecution) {
      if (this.cancellationExecuted) {
        return;
      }
    }
  }
  LOG.info(String.format("All tasks of job %s have completed",jobId));
  if (jobState.getState() == JobState.RunningState.RUNNING) {
    jobState.setState(JobState.RunningState.SUCCESSFUL);
  }
  for (  Task task : tasks) {
    jobState.addTaskState(task.getTaskState());
    if (task.getTaskState().getWorkingState() == WorkUnitState.WorkingState.FAILED) {
      this.eventSubmitter.submit("TaskFailed","taskId",task.getTaskId());
      jobState.setState(JobState.RunningState.FAILED);
    }
  }
}
