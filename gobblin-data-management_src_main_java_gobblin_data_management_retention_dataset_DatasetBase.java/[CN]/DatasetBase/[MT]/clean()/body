{
  RetentionPolicy<T> retentionPolicy=getRetentionPolicy();
  VersionFinder<? extends T> versionFinder=getVersionFinder();
  if (!retentionPolicy.versionClass().isAssignableFrom(versionFinder.versionClass())) {
    throw new IOException("Incompatible dataset version classes.");
  }
  LOGGER.info("Cleaning dataset " + this);
  List<T> versions=Lists.newArrayList(getVersionFinder().findDatasetVersions(this));
  Collections.sort(versions,Collections.reverseOrder());
  List<T> deletableVersions=getRetentionPolicy().preserveDeletableVersions(versions);
  Set<Path> possiblyEmptyDirectories=new HashSet<Path>();
  for (  DatasetVersion versionToDelete : deletableVersions) {
    LOGGER.info("Deleting dataset version " + versionToDelete);
    Set<Path> pathsToDelete=versionToDelete.getPathsToDelete();
    LOGGER.info("Deleting paths: " + Arrays.toString(pathsToDelete.toArray()));
    boolean deletedAllPaths=true;
    for (    Path path : pathsToDelete) {
      if (!this.simulate) {
        boolean successfullyDeleted;
        if (this.skipTrash) {
          successfullyDeleted=this.fs.delete(path,true);
        }
 else {
          successfullyDeleted=this.trash.moveToTrash(path);
        }
        if (successfullyDeleted) {
          possiblyEmptyDirectories.add(path.getParent());
        }
 else {
          LOGGER.error("Failed to delete path " + path + " in dataset version "+ versionToDelete);
          deletedAllPaths=false;
        }
      }
    }
    if (!deletedAllPaths) {
      LOGGER.error("Failed to delete some paths in dataset version " + versionToDelete);
    }
  }
  if (this.deleteEmptyDirectories) {
    for (    Path parentDirectory : possiblyEmptyDirectories) {
      deleteEmptyParentDirectories(datasetRoot(),parentDirectory);
    }
  }
}
