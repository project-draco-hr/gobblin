{
  try {
    final FileSystem sourceFs=getSourceFileSystem(state);
    final FileSystem targetFs=getTargetFileSystem(state);
    final ConcurrentBoundedWorkUnitList workUnitList=new ConcurrentBoundedWorkUnitList(state.getPropAsInt(MAX_FILES_COPIED_KEY,DEFAULT_MAX_FILES_COPIED),new AllEqualComparator<FileSet<CopyEntity>>());
    final CopyConfiguration copyConfiguration=CopyConfiguration.builder(targetFs,state.getProperties()).build();
    DatasetsFinder<CopyableDataset> datasetFinder=DatasetUtils.instantiateDatasetFinder(state.getProperties(),sourceFs,DEFAULT_DATASET_PROFILE_CLASS_KEY);
    IterableDatasetFinder<CopyableDataset> iterableDatasetFinder=datasetFinder instanceof IterableDatasetFinder ? (IterableDatasetFinder<CopyableDataset>)datasetFinder : new IterableDatasetFinderImpl<>(datasetFinder);
    Iterator<CopyableDataset> copyableDatasets=new InterruptibleIterator<>(iterableDatasetFinder.getDatasetsIterator(),new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return shouldStopGeneratingWorkUnits(workUnitList);
      }
    }
);
    Iterator<Callable<Void>> callableIterator=Iterators.transform(copyableDatasets,new Function<CopyableDataset,Callable<Void>>(){
      @Nullable @Override public Callable<Void> apply(      @Nullable CopyableDataset copyableDataset){
        return new DatasetWorkUnitGenerator(copyableDataset,sourceFs,targetFs,state,workUnitList,copyConfiguration);
      }
    }
);
    try {
      List<Future<Void>> futures=new IteratorExecutor<>(callableIterator,state.getPropAsInt(MAX_CONCURRENT_LISTING_SERVICES,DEFAULT_MAX_CONCURRENT_LISTING_SERVICES),ExecutorsUtils.newThreadFactory(Optional.of(log),Optional.of("Dataset-cleaner-pool-%d"))).execute();
      for (      Future<Void> future : futures) {
        try {
          future.get();
        }
 catch (        ExecutionException exc) {
          log.error("Failed to get work units for dataset.",exc);
        }
      }
    }
 catch (    InterruptedException ie) {
      log.error("Retrieval of work units was interrupted. Aborting.");
      return Lists.newArrayList();
    }
    log.info(String.format("Created %s workunits ",workUnitList.getWorkUnits().size()));
    if (state.contains(SIMULATE) && state.getPropAsBoolean(SIMULATE)) {
      Map<FileSet<CopyEntity>,List<WorkUnit>> copyEntitiesMap=workUnitList.getRawWorkUnitMap();
      log.info("Simulate mode enabled. Will not execute the copy.");
      for (      Map.Entry<FileSet<CopyEntity>,List<WorkUnit>> entry : copyEntitiesMap.entrySet()) {
        log.info(String.format("Actions for dataset %s file set %s.",entry.getKey().getDataset().datasetURN(),entry.getKey().getName()));
        for (        WorkUnit workUnit : entry.getValue()) {
          CopyEntity copyEntity=deserializeCopyEntity(workUnit);
          log.info(copyEntity.explain());
        }
      }
      return Lists.newArrayList();
    }
    return Lists.newArrayList(workUnitList.getWorkUnits());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}
