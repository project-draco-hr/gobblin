{
  CopyContext copyContext=new CopyContext();
  try {
    FileSystem sourceFs=getSourceFileSystem(state);
    FileSystem targetFs=getTargetFileSystem(state);
    DatasetFinder<CopyableDataset> datasetFinder=DatasetUtils.instantiateDatasetFinder(state.getProperties(),sourceFs,DEFAULT_DATASET_PROFILE_CLASS_KEY);
    List<CopyableDataset> copyableDatasets=datasetFinder.findDatasets();
    ConcurrentBoundedWorkUnitList workUnitList=new ConcurrentBoundedWorkUnitList(state.getPropAsInt(MAX_FILES_COPIED_KEY,DEFAULT_MAX_FILES_COPIED),new AllEqualComparator<FileSet<CopyableFile>>());
    ExecutorService executor=ScalingThreadPoolExecutor.newScalingThreadPool(0,state.getPropAsInt(MAX_CONCURRENT_LISTING_SERVICES,DEFAULT_MAX_CONCURRENT_LISTING_SERVICES),100,ExecutorsUtils.newThreadFactory(Optional.of(log),Optional.of("Dataset-cleaner-pool-%d")));
    ListeningExecutorService service=MoreExecutors.listeningDecorator(executor);
    List<ListenableFuture<?>> futures=Lists.newArrayList();
    for (    CopyableDataset copyableDataset : copyableDatasets) {
      Path targetRoot=getTargetRoot(state,datasetFinder,copyableDataset);
      futures.add(service.submit(new DatasetWorkUnitGenerator(copyableDataset,sourceFs,targetFs,state,targetRoot,copyContext,workUnitList)));
    }
    for (    ListenableFuture<?> future : futures) {
      try {
        future.get();
      }
 catch (      ExecutionException|InterruptedException exc) {
        throw new IOException("Failed to generate work units.",exc);
      }
    }
    log.info(String.format("Created %s workunits ",workUnitList.getWorkUnits().size()));
    return Lists.newArrayList(workUnitList.getWorkUnits());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}
