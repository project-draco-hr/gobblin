{
  Preconditions.checkNotNull(jobProps);
  Preconditions.checkArgument(jobProps.containsKey(ConfigurationKeys.JOB_NAME_KEY),"A job must have a job name specified by job.name");
  String jobName=jobProps.getProperty(ConfigurationKeys.JOB_NAME_KEY);
  if (Boolean.valueOf(jobProps.getProperty(ConfigurationKeys.JOB_DISABLED_KEY,Boolean.FALSE.toString()))) {
    LOG.info(String.format("Not launching job %s as it is disabled",jobName));
    return;
  }
  Optional<JobLock> jobLockOptional=Optional.absent();
  boolean jobLockEnabled=Boolean.valueOf(jobProps.getProperty(ConfigurationKeys.JOB_LOCK_ENABLED_KEY,Boolean.TRUE.toString()));
  if (jobLockEnabled) {
    try {
      jobLockOptional=Optional.of(getJobLock(jobName,jobProps));
    }
 catch (    IOException ioe) {
      throw new JobException("Failed to get job lock for job " + jobName,ioe);
    }
  }
  if (!tryLockJob(jobName,jobLockOptional)) {
    throw new JobException(String.format("Previous instance of job %s is still running, skipping this scheduled run",jobName));
  }
  String jobId=jobProps.getProperty(ConfigurationKeys.JOB_ID_KEY);
  if (Strings.isNullOrEmpty(jobId)) {
    jobId=JobLauncherUtils.newJobId(jobName);
    jobProps.setProperty(ConfigurationKeys.JOB_ID_KEY,jobId);
  }
  State jobPropsState=new State();
  jobPropsState.addAll(jobProps);
  JobState jobState;
  Source<?,?> source;
  try {
    JobState previousJobState=getPreviousJobState(jobName);
    jobState=new JobState(jobPropsState,previousJobState.getTaskStatesAsWorkUnitStates(),jobName,jobId);
    jobState.setProp(ConfigurationKeys.JOB_FAILURES_KEY,previousJobState.getPropAsInt(ConfigurationKeys.JOB_FAILURES_KEY,0));
    source=new SourceDecorator(initSource(jobProps),jobId,LOG);
  }
 catch (  Throwable t) {
    String errMsg="Failed to initialize the source for job " + jobId;
    LOG.error(errMsg + ": " + t,t);
    unlockJob(jobName,jobLockOptional);
    throw new JobException(errMsg,t);
  }
  JobMetrics jobMetrics=JobMetrics.get(jobState);
  jobState.setProp(ConfigurationKeys.METRIC_CONTEXT_NAME_KEY,jobMetrics.getName());
  jobState.setState(JobState.RunningState.PENDING);
  boolean metricsEnabled=GobblinMetrics.isEnabled(jobState);
  Timer.Context createWorkUnitsTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.CREATE_WORK_UNITS).time();
  Optional<List<WorkUnit>> workUnits=Optional.fromNullable(source.getWorkunits(jobState));
  if (!workUnits.isPresent()) {
    source.shutdown(jobState);
    unlockJob(jobName,jobLockOptional);
    throw new JobException("Failed to get work units for job " + jobId);
  }
  createWorkUnitsTimer.stop();
  if (workUnits.get().isEmpty()) {
    LOG.warn("No work units have been created for job " + jobId);
    source.shutdown(jobState);
    unlockJob(jobName,jobLockOptional);
    return;
  }
  long startTime=System.currentTimeMillis();
  jobState.setStartTime(startTime);
  jobState.setState(JobState.RunningState.RUNNING);
  LOG.info("Starting job " + jobId);
  Timer.Context addWorkUnitsTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.ADD_WORK_UNITS).time();
  int taskIdSequence=0;
  int multiTaskIdSequence=0;
  for (  WorkUnit workUnit : workUnits.get()) {
    if (workUnit instanceof MultiWorkUnit) {
      String multiTaskId=JobLauncherUtils.newMultiTaskId(jobId,multiTaskIdSequence++);
      workUnit.setProp(ConfigurationKeys.TASK_ID_KEY,multiTaskId);
      workUnit.setId(multiTaskId);
      for (      WorkUnit innerWorkUnit : ((MultiWorkUnit)workUnit).getWorkUnits()) {
        addWorkUnit(innerWorkUnit,jobState,taskIdSequence++);
      }
    }
 else {
      addWorkUnit(workUnit,jobState,taskIdSequence++);
    }
  }
  addWorkUnitsTimer.stop();
  try {
    if (GobblinMetrics.isEnabled(jobProps)) {
      jobMetrics.startMetricReporting(jobProps);
    }
    Timer.Context writeJobHistoryTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.WRITE_JOB_HISTORY).time();
    if (this.jobHistoryStore.isPresent()) {
      try {
        this.jobHistoryStore.get().put(jobState.toJobExecutionInfo());
      }
 catch (      Throwable t) {
        LOG.error("Failed to write job execution information to the job history store: " + t,t);
      }
    }
    writeJobHistoryTimer.stop();
    Timer.Context runJobTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.RUN_JOB).time();
    runJob(jobName,jobProps,jobState,workUnits.get());
    runJobTimer.stop();
    if (jobState.getState() == JobState.RunningState.CANCELLED) {
      LOG.info(String.format("Job %s has been cancelled",jobId));
      return;
    }
    Timer.Context commitJobTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.COMMIT_JOB).time();
    JobCommitPolicy commitPolicy=JobCommitPolicy.getCommitPolicy(jobState);
    setFinalJobState(commitPolicy,jobState);
    commitJob(jobId,commitPolicy,jobState);
    commitJobTimer.stop();
  }
 catch (  Throwable t) {
    jobState.setState(JobState.RunningState.FAILED);
    String errMsg="Failed to launch and run job " + jobId;
    LOG.error(errMsg + ": " + t,t);
    throw new JobException(errMsg,t);
  }
 finally {
    Timer.Context jobCleanupTimer=jobMetrics.getTimer(MetricNames.LauncherTimings.CLEANUP_JOB).time();
    source.shutdown(jobState);
    try {
      persistJobState(jobState);
    }
 catch (    Throwable t) {
      LOG.error(String.format("Failed to persist job/task states of job %s: %s",jobId,t),t);
      jobState.setState(JobState.RunningState.FAILED);
    }
    cleanupStagingData(jobState);
    long endTime=System.currentTimeMillis();
    jobState.setEndTime(endTime);
    jobState.setDuration(endTime - startTime);
    unlockJob(jobName,jobLockOptional);
    if (this.jobHistoryStore.isPresent()) {
      try {
        this.jobHistoryStore.get().put(jobState.toJobExecutionInfo());
      }
 catch (      Throwable t) {
        LOG.error("Failed to write job execution information to the job history store: " + t,t);
      }
    }
    jobCleanupTimer.stop();
    if (GobblinMetrics.isEnabled(jobProps)) {
      jobMetrics.triggerMetricReporting();
      jobMetrics.stopMetricReporting();
      JobMetrics.remove(jobState);
    }
  }
  if (Optional.fromNullable(jobListener).isPresent()) {
    jobListener.jobCompleted(jobState);
  }
  if (jobState.getState() == JobState.RunningState.FAILED) {
    throw new JobException(String.format("Job %s failed",jobId));
  }
}
