{
  if (this.jobContext.getJobMetricsOptional().isPresent()) {
    this.jobContext.getJobMetricsOptional().get().startMetricReporting(this.jobProps);
  }
  TimingEvent launchJobTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.FULL_JOB_EXECUTION);
  String jobId=this.jobContext.getJobId();
  JobState jobState=this.jobContext.getJobState();
  try {
    if (!tryLockJob()) {
      this.eventSubmitter.submit(gobblin.metrics.event.EventNames.LOCK_IN_USE);
      throw new JobException(String.format("Previous instance of job %s is still running, skipping this scheduled run",this.jobContext.getJobName()));
    }
    TimingEvent workUnitsCreationTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.WORK_UNITS_CREATION);
    Optional<List<WorkUnit>> workUnits=Optional.fromNullable(this.jobContext.getSource().getWorkunits(jobState));
    workUnitsCreationTimer.stop();
    if (!workUnits.isPresent()) {
      this.eventSubmitter.submit(gobblin.metrics.event.EventNames.WORK_UNITS_MISSING);
      jobState.setState(JobState.RunningState.FAILED);
      throw new JobException("Failed to get work units for job " + jobId);
    }
    if (workUnits.get().isEmpty()) {
      this.eventSubmitter.submit(gobblin.metrics.event.EventNames.WORK_UNITS_EMPTY);
      LOG.warn("No work units have been created for job " + jobId);
      return;
    }
    long startTime=System.currentTimeMillis();
    jobState.setStartTime(startTime);
    jobState.setState(JobState.RunningState.RUNNING);
    LOG.info("Starting job " + jobId);
    TimingEvent workUnitsPreparationTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.WORK_UNITS_PREPARATION);
    prepareWorkUnits(JobLauncherUtils.flattenWorkUnits(workUnits.get()),jobState);
    workUnitsPreparationTimer.stop();
    this.jobContext.storeJobExecutionInfo();
    TimingEvent jobRunTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.JOB_RUN);
    runWorkUnits(workUnits.get());
    jobRunTimer.stop();
    this.eventSubmitter.submit(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL,"JOB_" + jobState.getState()));
    if (jobState.getState() == JobState.RunningState.CANCELLED) {
      LOG.info(String.format("Job %s has been cancelled, aborting now",jobId));
      return;
    }
    TimingEvent jobCommitTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.JOB_COMMIT);
    this.jobContext.finalizeJobStateBeforeCommit();
    this.jobContext.commit();
    postProcessTaskStates(jobState.getTaskStates());
    jobCommitTimer.stop();
  }
 catch (  Throwable t) {
    jobState.setState(JobState.RunningState.FAILED);
    String errMsg="Failed to launch and run job " + jobId;
    LOG.error(errMsg + ": " + t,t);
    throw new JobException(errMsg,t);
  }
 finally {
    long endTime=System.currentTimeMillis();
    jobState.setEndTime(endTime);
    jobState.setDuration(endTime - jobState.getStartTime());
    TimingEvent jobCleanupTimer=this.eventSubmitter.getTimingEvent(TimingEventNames.LauncherTimings.JOB_CLEANUP);
    cleanupStagingData(jobState);
    jobCleanupTimer.stop();
    this.jobContext.storeJobExecutionInfo();
    launchJobTimer.stop();
    if (this.jobContext.getJobMetricsOptional().isPresent()) {
      this.jobContext.getJobMetricsOptional().get().triggerMetricReporting();
      this.jobContext.getJobMetricsOptional().get().stopMetricReporting();
      JobMetrics.remove(jobState);
    }
    unlockJob();
  }
  for (  JobState.DatasetState datasetState : this.jobContext.getDatasetStatesByUrns().values()) {
    if (datasetState.getState() == JobState.RunningState.FAILED) {
      jobState.setState(JobState.RunningState.FAILED);
      break;
    }
  }
  if (jobListener != null) {
    jobListener.onJobCompletion(jobState);
  }
  if (jobState.getState() == JobState.RunningState.FAILED) {
    throw new JobException(String.format("Job %s failed",jobId));
  }
}
