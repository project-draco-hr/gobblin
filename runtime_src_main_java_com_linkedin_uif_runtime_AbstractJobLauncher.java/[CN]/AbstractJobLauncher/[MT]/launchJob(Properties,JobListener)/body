{
  Preconditions.checkNotNull(jobProps);
  String jobName=jobProps.getProperty(ConfigurationKeys.JOB_NAME_KEY);
  if (Strings.isNullOrEmpty(jobName)) {
    throw new JobException("A job must have a job name specified by job.name");
  }
  String jobDisabled=jobProps.getProperty(ConfigurationKeys.JOB_DISABLED_KEY,"false");
  if (Boolean.valueOf(jobDisabled)) {
    LOG.info(String.format("Not launching job %s as it is disabled",jobName));
    return;
  }
  Optional<JobLock> jobLockOptional=Optional.absent();
  boolean jobLockEnabled=Boolean.valueOf(jobProps.getProperty(ConfigurationKeys.JOB_LOCK_ENABLED_KEY,Boolean.TRUE.toString()));
  if (jobLockEnabled) {
    try {
      jobLockOptional=Optional.of(getJobLock(jobName,jobProps));
    }
 catch (    IOException ioe) {
      throw new JobException("Failed to get job lock for job " + jobName,ioe);
    }
  }
  if (!tryLockJob(jobName,jobLockOptional)) {
    throw new JobException(String.format("Previous instance of job %s is still running, skipping this scheduled run",jobName));
  }
  String jobId=jobProps.getProperty(ConfigurationKeys.JOB_ID_KEY);
  if (Strings.isNullOrEmpty(jobId)) {
    jobId=JobLauncherUtils.newJobId(jobName);
    jobProps.setProperty(ConfigurationKeys.JOB_ID_KEY,jobId);
  }
  JobState jobState=new JobState(jobName,jobId);
  jobState.addAll(jobProps);
  jobState.setProp(ConfigurationKeys.JOB_FAILURES_KEY,getFailureCount(jobName));
  jobState.setState(JobState.RunningState.PENDING);
  LOG.info("Starting job " + jobId);
  SourceState sourceState;
  Source<?,?> source;
  try {
    sourceState=new SourceState(jobState,getPreviousWorkUnitStates(jobName));
    source=new SourceDecorator(initSource(jobProps),jobId,LOG);
  }
 catch (  Throwable t) {
    String errMsg="Failed to initialize the source for job " + jobId;
    LOG.error(errMsg,t);
    unlockJob(jobName,jobLockOptional);
    throw new JobException(errMsg,t);
  }
  Optional<List<WorkUnit>> workUnits=Optional.fromNullable(source.getWorkunits(sourceState));
  if (!workUnits.isPresent()) {
    source.shutdown(sourceState);
    unlockJob(jobName,jobLockOptional);
    throw new JobException("Failed to get work units for job " + jobId);
  }
  if (workUnits.get().isEmpty()) {
    LOG.warn("No work units have been created for job " + jobId);
    source.shutdown(sourceState);
    unlockJob(jobName,jobLockOptional);
    return;
  }
  long startTime=System.currentTimeMillis();
  jobState.setStartTime(startTime);
  jobState.setState(JobState.RunningState.RUNNING);
  int sequence=0;
  for (  WorkUnit workUnit : workUnits.get()) {
    if (workUnit instanceof MultiWorkUnit) {
      for (      WorkUnit innerWorkUnit : ((MultiWorkUnit)workUnit).getWorkUnits()) {
        addWorkUnit(innerWorkUnit,jobState,sequence++);
      }
    }
 else {
      addWorkUnit(workUnit,jobState,sequence++);
    }
  }
  Optional<JobMetrics> jobMetrics=Optional.absent();
  try {
    if (JobMetrics.isEnabled(jobProps)) {
      jobMetrics=Optional.fromNullable(JobMetrics.get(jobName,jobId));
      if (jobMetrics.isPresent()) {
        jobMetrics.get().startMetricReporting(jobProps);
      }
    }
    runJob(jobName,jobProps,jobState,workUnits.get());
    if (jobState.getState() == JobState.RunningState.CANCELLED) {
      LOG.info(String.format("Job %s has been cancelled",jobId));
      return;
    }
    setFinalJobState(jobState);
    commitJob(jobId,jobState);
  }
 catch (  Throwable t) {
    String errMsg="Failed to launch and run job " + jobId;
    LOG.error(errMsg,t);
    throw new JobException(errMsg,t);
  }
 finally {
    source.shutdown(sourceState);
    long endTime=System.currentTimeMillis();
    jobState.setEndTime(endTime);
    jobState.setDuration(endTime - startTime);
    try {
      persistJobState(jobState);
      cleanupStagingData(jobState);
    }
 catch (    Throwable t) {
      LOG.error("Failed to persist job state and cleanup for job " + jobId,t);
    }
    unlockJob(jobName,jobLockOptional);
    if (JobMetrics.isEnabled(jobProps)) {
      if (jobMetrics.isPresent()) {
        jobMetrics.get().stopMetricReporting();
      }
      JobMetrics.remove(jobId);
    }
    if (Optional.fromNullable(jobListener).isPresent()) {
      jobListener.jobCompleted(jobState);
    }
  }
  if (jobState.getState() == JobState.RunningState.FAILED) {
    throw new JobException(String.format("Job %s failed",jobId));
  }
}
