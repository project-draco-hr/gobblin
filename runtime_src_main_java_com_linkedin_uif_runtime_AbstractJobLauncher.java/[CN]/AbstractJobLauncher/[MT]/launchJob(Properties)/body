{
  Preconditions.checkNotNull(jobProps);
  jobProps.putAll(this.properties);
  String jobName=jobProps.getProperty(ConfigurationKeys.JOB_NAME_KEY);
  if (Strings.isNullOrEmpty(jobName)) {
    throw new JobException("A job must have a job name specified by job.name");
  }
  String jobDisabled=jobProps.getProperty(ConfigurationKeys.JOB_DISABLED_KEY,"false");
  if (Boolean.valueOf(jobDisabled)) {
    LOG.info(String.format("Not launching job %s as it is disabled",jobName));
    return;
  }
  JobLock jobLock;
  try {
    jobLock=getJobLock(jobName,jobProps);
  }
 catch (  IOException ioe) {
    throw new JobException("Failed to get job lock for job " + jobName,ioe);
  }
  if (!tryLockJob(jobName,jobLock)) {
    LOG.info(String.format("Previous instance of job %s is still running, skipping this scheduled run",jobName));
    return;
  }
  String jobId=jobProps.getProperty(ConfigurationKeys.JOB_ID_KEY);
  if (Strings.isNullOrEmpty(jobId)) {
    jobId=JobLauncherUtil.newJobId(jobName);
    jobProps.setProperty(ConfigurationKeys.JOB_ID_KEY,jobId);
  }
  JobState jobState=new JobState(jobName,jobId);
  jobState.addAll(jobProps);
  jobState.setProp(ConfigurationKeys.JOB_FAILURES_KEY,getFailureCount(jobName));
  LOG.info("Starting job " + jobId);
  SourceState sourceState;
  SourceWrapperBase source;
  try {
    sourceState=new SourceState(jobState,getPreviousWorkUnitStates(jobName));
    source=initSource(jobProps,sourceState);
  }
 catch (  Throwable t) {
    String errMsg="Failed to initialize the source for job " + jobId;
    LOG.error(errMsg,t);
    unlockJob(jobName,jobLock);
    throw new JobException(errMsg,t);
  }
  List<WorkUnit> workUnits;
  try {
    workUnits=source.getWorkunits(sourceState);
  }
 catch (  Throwable t) {
    String errMsg="Failed to get work units for job " + jobId;
    LOG.error(errMsg,t);
    try {
      source.shutdown(sourceState);
    }
 catch (    Throwable t1) {
      LOG.error("Failed to shutdown the source for job " + jobId,t1);
    }
    unlockJob(jobName,jobLock);
    throw new JobException(errMsg,t);
  }
  if (workUnits == null || workUnits.isEmpty()) {
    LOG.warn("No work units to do for job " + jobId);
    try {
      source.shutdown(sourceState);
    }
 catch (    Throwable t) {
      LOG.error("Failed to shutdown the source for job " + jobId,t);
    }
    unlockJob(jobName,jobLock);
    return;
  }
  jobState.setTasks(workUnits.size());
  jobState.setStartTime(System.currentTimeMillis());
  jobState.setState(JobState.RunningState.WORKING);
  int sequence=0;
  for (  WorkUnit workUnit : workUnits) {
    String taskId=JobLauncherUtil.newTaskId(jobId,sequence++);
    workUnit.setId(taskId);
    workUnit.setProp(ConfigurationKeys.JOB_ID_KEY,jobId);
    workUnit.setProp(ConfigurationKeys.TASK_ID_KEY,taskId);
  }
  try {
    runJob(jobName,jobProps,jobState,workUnits);
    jobState=getFinalJobState(jobState);
    commitJob(jobId,jobState);
  }
 catch (  Throwable t) {
    String errMsg="Failed to launch job " + jobId;
    LOG.error(errMsg,t);
    jobState.setState(JobState.RunningState.FAILED);
    throw new JobException(errMsg,t);
  }
 finally {
    try {
      source.shutdown(sourceState);
      persistJobState(jobState);
      cleanupStagingData(jobState);
    }
 catch (    Throwable t) {
      LOG.error("Failed to cleanup for job " + jobId,t);
    }
    unlockJob(jobName,jobLock);
  }
}
