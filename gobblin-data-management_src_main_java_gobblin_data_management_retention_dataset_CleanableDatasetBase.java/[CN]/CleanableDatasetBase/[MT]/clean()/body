{
  RetentionPolicy<T> retentionPolicy=getRetentionPolicy();
  VersionFinder<? extends T> versionFinder=getVersionFinder();
  if (!retentionPolicy.versionClass().isAssignableFrom(versionFinder.versionClass())) {
    throw new IOException("Incompatible dataset version classes.");
  }
  this.log.info("Cleaning dataset " + this);
  List<T> versions=Lists.newArrayList(getVersionFinder().findDatasetVersions(this));
  if (versions.isEmpty()) {
    this.log.warn("No dataset version can be found. Ignoring.");
    return;
  }
  Collections.sort(versions,Collections.reverseOrder());
  Collection<T> deletableVersions=getRetentionPolicy().listDeletableVersions(versions);
  if (deletableVersions.isEmpty()) {
    this.log.warn("No deletable dataset version can be found. Ignoring.");
    return;
  }
  Set<Path> possiblyEmptyDirectories=new HashSet<Path>();
  for (  DatasetVersion versionToDelete : deletableVersions) {
    this.log.info("Deleting dataset version " + versionToDelete);
    Set<Path> pathsToDelete=versionToDelete.getPathsToDelete();
    this.log.info("Deleting paths: " + Arrays.toString(pathsToDelete.toArray()));
    boolean deletedAllPaths=true;
    for (    Path path : pathsToDelete) {
      boolean successfullyDeleted=this.deleteAsOwner ? this.trash.moveToTrashAsOwner(path) : this.trash.moveToTrash(path);
      if (successfullyDeleted) {
        possiblyEmptyDirectories.add(path.getParent());
      }
 else {
        this.log.error("Failed to delete path " + path + " in dataset version "+ versionToDelete);
        deletedAllPaths=false;
      }
    }
    if (!deletedAllPaths) {
      this.log.error("Failed to delete some paths in dataset version " + versionToDelete);
    }
  }
  if (this.deleteEmptyDirectories) {
    for (    Path parentDirectory : possiblyEmptyDirectories) {
      deleteEmptyParentDirectories(datasetRoot(),parentDirectory);
    }
  }
}
