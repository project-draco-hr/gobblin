{
  DiffPathSet.DiffPathSetBuilder builder=DiffPathSet.builder();
  multiTimer.nextStage(Stages.SOURCE_PATH_LISTING);
  Set<Path> sourcePaths=sourceLocation.getPaths();
  multiTimer.nextStage(Stages.TARGET_EXISTING_PATH_LISTING);
  Set<Path> targetExistingPaths=currentTargetLocation.isPresent() ? currentTargetLocation.get().getPaths() : Sets.<Path>newHashSet();
  multiTimer.nextStage(Stages.DESIRED_PATHS_LISTING);
  Set<Path> desiredTargetExistingPaths;
  try {
    desiredTargetExistingPaths=desiredTargetLocation.getPaths();
  }
 catch (  InvalidInputException ioe) {
    desiredTargetExistingPaths=Sets.newHashSet();
  }
  multiTimer.nextStage(Stages.PATH_DIFF);
  for (  Path sourcePath : sourcePaths) {
    Path newPath=getTargetPath(sourcePath,desiredTargetLocation.getFileSystem(),partition,true);
    boolean shouldCopy=true;
    FileStatus originStatus=sourceLocation.getFileSystem().getFileStatus(sourcePath);
    if (desiredTargetExistingPaths.contains(newPath)) {
      FileStatus existingTargetStatus=desiredTargetLocation.getFileSystem().getFileStatus(newPath);
      if (!shouldReplaceFile(existingTargetStatus,originStatus)) {
        shouldCopy=false;
      }
    }
    if (shouldCopy) {
      builder.copyFile(originStatus);
    }
 else {
      targetExistingPaths.remove(newPath);
      desiredTargetExistingPaths.remove(newPath);
    }
  }
  multiTimer.nextStage(Stages.COMPUTE_DELETE_PATHS);
  for (  Path delete : targetExistingPaths) {
    builder.deleteFile(delete);
    desiredTargetExistingPaths.remove(delete);
  }
  if (desiredTargetExistingPaths.size() > 0) {
    throw new IOException(String.format("New table / partition would pick up existing, undesired files in target file system. " + "%s, files %s.",partition.isPresent() ? partition.get().getCompleteName() : dataset.table.getCompleteName(),Arrays.toString(desiredTargetExistingPaths.toArray())));
  }
  return builder.build();
}
