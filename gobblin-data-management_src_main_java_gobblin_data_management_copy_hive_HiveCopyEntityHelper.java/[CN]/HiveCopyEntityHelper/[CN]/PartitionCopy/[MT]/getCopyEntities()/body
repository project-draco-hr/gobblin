{
  int stepPriority=0;
  String fileSet=gson.toJson(this.partition.getValues());
  List<CopyEntity> copyEntities=Lists.newArrayList();
  stepPriority=addSharedSteps(copyEntities,fileSet,stepPriority);
  InputFormat<?,?> inputFormat=HiveDataset.getInputFormat(this.partition.getTPartition().getSd());
  Optional<Partition> targetPartition=Optional.fromNullable(targetPartitions.get(partition.getValues()));
  if (targetPartition.isPresent()) {
    targetPartitions.remove(partition.getValues());
    try {
      checkPartitionCompatibility(partition,targetPartition.get());
    }
 catch (    IOException ioe) {
      if (existingEntityPolicy == ExistingEntityPolicy.ABORT) {
        log.error("Source and target partitions are not compatible. Aborting copy of partition " + this.partition);
        return Lists.newArrayList();
      }
      log.warn("Source and target partitions are not compatible. Will override target partition.");
      stepPriority=addDeregisterSteps(copyEntities,fileSet,stepPriority,targetTable,targetPartition.get());
      targetPartition=Optional.absent();
    }
  }
  dataset.fs.getFileStatus(new Path("/user/ketl_dev"));
  Collection<Path> sourcePaths=HiveDataset.getPaths(inputFormat,partition.getLocation());
  Collection<Path> targetExistingPaths=targetPartition.isPresent() ? HiveDataset.getPaths(inputFormat,targetPartition.get().getLocation()) : Sets.<Path>newHashSet();
  DiffPathSet diffPathSet=diffSourceAndTargetPaths(sourcePaths,targetExistingPaths,Optional.of(partition),targetFs);
  DeleteFileCommitStep deleteStep=DeleteFileCommitStep.fromPaths(targetFs,diffPathSet.pathsToDelete,dataset.properties);
  copyEntities.add(new PrePublishStep(fileSet,Maps.<String,Object>newHashMap(),deleteStep,stepPriority++));
  for (  CopyableFile.Builder builder : getCopyableFilesFromPaths(diffPathSet.filesToCopy,configuration,Optional.of(partition))) {
    copyEntities.add(builder.fileSet(fileSet).build());
  }
  if (!targetPartition.isPresent()) {
    Path targetPath=getTargetLocation(dataset.fs,targetFs,HiveDataset.parseLocationIntoPaths(this.partition.getDataLocation()),Optional.of(this.partition));
    Partition newTargetPartition=getTargetPartition(this.partition,targetPath);
    HiveSpec partitionHiveSpec=new SimpleHiveSpec.Builder<>(targetPath).withTable(HiveMetaStoreUtils.getHiveTable(targetTable.getTTable())).withPartition(Optional.of(HiveMetaStoreUtils.getHivePartition(newTargetPartition.getTPartition()))).build();
    HiveRegisterStep register=new HiveRegisterStep(targetURI,partitionHiveSpec,hiveRegProps);
    copyEntities.add(new PostPublishStep(fileSet,Maps.<String,Object>newHashMap(),register,stepPriority++));
  }
  return copyEntities;
}
