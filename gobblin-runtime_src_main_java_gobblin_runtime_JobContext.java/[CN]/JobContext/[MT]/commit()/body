{
  this.datasetStatesByUrns=Optional.of(this.jobState.createDatasetStatesByUrns());
  boolean allDatasetsCommit=true;
  boolean shouldCommitDataInJob=shouldCommitDataInJob(this.jobState);
  DeliverySemantics deliverySemantics=DeliverySemantics.parse(this.jobState);
  if (!shouldCommitDataInJob) {
    this.logger.info("Job will not commit data since data are committed by tasks.");
  }
  for (  Map.Entry<String,JobState.DatasetState> entry : this.datasetStatesByUrns.get().entrySet()) {
    String datasetUrn=entry.getKey();
    JobState.DatasetState datasetState=entry.getValue();
    finalizeDatasetStateBeforeCommit(datasetState);
    Class<? extends DataPublisher> dataPublisherClass;
    try (Closer closer=Closer.create()){
      dataPublisherClass=getJobDataPublisherClass(datasetState).or((Class<? extends DataPublisher>)Class.forName(ConfigurationKeys.DEFAULT_DATA_PUBLISHER_TYPE));
      if (!canCommitDataset(datasetState)) {
        this.logger.warn(String.format("Not committing dataset %s of job %s with commit policy %s and state %s",datasetUrn,this.jobId,this.jobCommitPolicy,datasetState.getState()));
        allDatasetsCommit=false;
        if (UnpublishedHandling.class.isAssignableFrom(dataPublisherClass)) {
          DataPublisher publisher=closer.register(DataPublisher.getInstance(dataPublisherClass,datasetState));
          this.logger.info(String.format("Calling publisher to handle unpublished work units for dataset %s of job %s.",datasetUrn,this.jobId));
          ((UnpublishedHandling)publisher).handleUnpublishedWorkUnits(datasetState.getTaskStatesAsWorkUnitStates());
        }
        continue;
      }
    }
 catch (    ReflectiveOperationException roe) {
      throw new IOException(roe);
    }
    try (Closer closer=Closer.create()){
      if (shouldCommitDataInJob) {
        this.logger.info(String.format("Committing dataset %s of job %s with commit policy %s and state %s",datasetUrn,this.jobId,this.jobCommitPolicy,datasetState.getState()));
        if (deliverySemantics == DeliverySemantics.EXACTLY_ONCE) {
          generateCommitSequenceBuilder(datasetState);
        }
 else {
          commitDataset(datasetState,closer.register(DataPublisher.getInstance(dataPublisherClass,datasetState)));
        }
      }
 else {
        if (datasetState.getState() == JobState.RunningState.SUCCESSFUL) {
          datasetState.setState(JobState.RunningState.COMMITTED);
        }
      }
    }
 catch (    ReflectiveOperationException roe) {
      this.logger.error(String.format("Failed to instantiate data publisher for dataset %s of job %s.",datasetUrn,this.jobId),roe);
    }
catch (    IOException ioe) {
      this.logger.error(String.format("Failed to commit dataset state for dataset %s of job %s",datasetUrn,this.jobId),ioe);
      allDatasetsCommit=false;
    }
 finally {
      try {
        finalizeDatasetState(datasetState,datasetUrn);
        if (this.commitSequenceBuilder.isPresent()) {
          buildAndExecuteCommitSequence(commitSequenceBuilder.get(),datasetState,datasetUrn);
          datasetState.setState(JobState.RunningState.COMMITTED);
        }
 else {
          persistDatasetState(datasetUrn,datasetState);
        }
      }
 catch (      IOException ioe) {
        this.logger.error(String.format("Failed to persist dataset state for dataset %s of job %s",datasetUrn,this.jobId),ioe);
        allDatasetsCommit=false;
      }
    }
  }
  if (!allDatasetsCommit) {
    this.jobState.setState(JobState.RunningState.FAILED);
    throw new IOException("Failed to commit dataset state for some dataset(s) of job " + this.jobId);
  }
 else {
    this.jobState.setState(JobState.RunningState.COMMITTED);
  }
}
