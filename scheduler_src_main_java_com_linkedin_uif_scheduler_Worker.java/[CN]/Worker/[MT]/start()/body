{
  this.serviceManager.addListener(new ServiceManager.Listener(){
    @Override public void stopped(){
      LOG.info("Worker has been stopped");
    }
    @Override public void healthy(){
      LOG.info("All services are health and running");
      Map<Service,Long> startupTimes=serviceManager.startupTimes();
      for (      Map.Entry<Service,Long> entry : startupTimes.entrySet()) {
        LOG.info(String.format("Service %s is healthy with an uptime of %dms",entry.getKey().toString(),entry.getValue()));
      }
    }
    @Override public void failure(    Service service){
      LOG.error(String.format("Service %s failed for the following reason:\n\t%s",service.toString(),service.failureCause().toString()));
      System.exit(1);
    }
  }
,Executors.newSingleThreadExecutor());
  if (Metrics.isEnabled(this.properties)) {
    long metricsReportInterval=Long.parseLong(this.properties.getProperty(ConfigurationKeys.METRICS_REPORT_INTERVAL_KEY,ConfigurationKeys.DEFAULT_METRICS_REPORT_INTERVAL));
    Metrics.startSlf4jReporter(metricsReportInterval,LoggerFactory.getLogger(Worker.class));
    Metrics.startCsvReporter(metricsReportInterval,this.properties.getProperty(ConfigurationKeys.METRICS_DIR_KEY));
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    public void run(){
      LOG.info("Shutting down the worker");
      try {
        serviceManager.stopAsync().awaitStopped(5,TimeUnit.SECONDS);
      }
 catch (      TimeoutException te) {
        LOG.error(te);
      }
    }
  }
);
  LOG.info("Starting the worker with configured services");
  this.serviceManager.startAsync();
}
