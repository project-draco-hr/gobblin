{
  LOG.info("Start publishing data");
  int branches=state.getPropAsInt(ConfigurationKeys.FORK_BRANCHES_KEY,1);
  Set<String> emptiedDestTables=Sets.newHashSet();
  JdbcWriterCommands commands=jdbcWriterCommandsFactory.newInstance(state);
  Connection conn=createConnection();
  try {
    conn.setAutoCommit(false);
    for (int i=0; i < branches; i++) {
      String destinationTable=state.getProp(ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.JDBC_PUBLISHER_FINAL_TABLE_NAME,branches,i));
      Objects.requireNonNull(destinationTable);
      if (state.getPropAsBoolean(ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.JDBC_PUBLISHER_REPLACE_FINAL_TABLE,branches,i),false) && !emptiedDestTables.contains(destinationTable)) {
        LOG.info("Deleting table " + destinationTable);
        commands.deleteAll(conn,destinationTable);
        emptiedDestTables.add(destinationTable);
      }
      Map<String,List<WorkUnitState>> stagingTables=getStagingTables(states,branches,i);
      for (      Map.Entry<String,List<WorkUnitState>> entry : stagingTables.entrySet()) {
        String stagingTable=entry.getKey();
        LOG.info("Copying data from staging table + " + stagingTable + " into destination table "+ destinationTable);
        commands.copyTable(conn,stagingTable,destinationTable);
        for (        WorkUnitState workUnitState : entry.getValue()) {
          workUnitState.setWorkingState(WorkUnitState.WorkingState.COMMITTED);
        }
      }
    }
    LOG.info("Commit publish data");
    conn.commit();
  }
 catch (  Exception e) {
    try {
      LOG.error("Failed publishing. Rolling back.");
      conn.rollback();
    }
 catch (    SQLException se) {
      LOG.error("Failed rolling back.",se);
    }
    throw new RuntimeException("Failed publishing",e);
  }
 finally {
    try {
      conn.close();
    }
 catch (    SQLException e) {
      throw new RuntimeException(e);
    }
  }
}
