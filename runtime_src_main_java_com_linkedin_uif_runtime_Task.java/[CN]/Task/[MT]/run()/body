{
  Extractor extractor=null;
  TaskPublisher publisher=null;
  RowLevelPolicyChecker rowChecker=null;
  long startTime=System.currentTimeMillis();
  this.taskState.setStartTime(startTime);
  boolean shouldCommit=false;
  try {
    extractor=this.taskContext.getSource().getExtractor(this.taskState);
    if (extractor == null) {
      LOG.error("No extractor created for task " + this.taskId);
      return;
    }
    Object sourceSchema=extractor.getSchema();
    if (sourceSchema == null) {
      LOG.error("Not extracting data because no source schema available for task " + this.taskId);
      return;
    }
    boolean doConversion=!this.taskContext.getConverters().isEmpty();
    Converter converter=null;
    Object schemaForWriter=sourceSchema;
    if (doConversion) {
      converter=new MultiConverter(this.taskContext.getConverters());
      schemaForWriter=converter.convertSchema(sourceSchema,this.taskState);
    }
    rowChecker=buildRowLevelPolicyChecker(this.taskState);
    RowLevelPolicyCheckResults rowResults=new RowLevelPolicyCheckResults();
    this.writer=buildWriter(this.taskContext,schemaForWriter);
    this.taskState.setWorkingState(WorkUnitState.WorkingState.WORKING);
    this.taskStateTracker.registerNewTask(this);
    Object record;
    while ((record=extractor.readRecord()) != null) {
      if (doConversion) {
        record=converter.convertRecord(sourceSchema,record,this.taskState);
      }
      if (rowChecker.executePolicies(record,rowResults)) {
        this.writer.write(record);
      }
    }
    LOG.info("Row quality checker finished with results: " + rowResults.getResults());
    this.taskState.setProp(ConfigurationKeys.EXTRACTOR_ROWS_READ,extractor.getExpectedRecordCount());
    this.taskState.setProp(ConfigurationKeys.WRITER_ROWS_WRITTEN,this.writer.recordsWritten());
    this.taskState.setProp(ConfigurationKeys.EXTRACT_SCHEMA,schemaForWriter.toString());
    TaskLevelPolicyChecker policyChecker=buildTaskLevelPolicyChecker(this.taskState);
    TaskLevelPolicyCheckResults taskResults=policyChecker.executePolicies();
    publisher=buildTaskPublisher(this.taskState,taskResults);
switch (publisher.canPublish()) {
case SUCCESS:
      shouldCommit=true;
    this.taskState.setWorkingState(WorkUnitState.WorkingState.SUCCESSFUL);
  break;
case CLEANUP_FAIL:
LOG.error("Cleanup failed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
case POLICY_TESTS_FAIL:
LOG.error("Not all quality checking passed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
case COMPONENTS_NOT_FINISHED:
LOG.error("Not all components completed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
default :
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
}
}
 catch (Exception e) {
LOG.error(String.format("Task %s failed",this.taskId),e);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
this.taskState.setProp(ConfigurationKeys.TASK_FAILURE_EXCEPTION_KEY,e.toString());
}
 finally {
if (extractor != null) {
try {
extractor.close();
}
 catch (Exception ioe) {
LOG.error("Failed to close the extractor for task " + taskId,ioe);
}
}
if (this.writer != null) {
try {
this.writer.close();
if (shouldCommit) {
LOG.info("Committing data of task " + this.taskId);
this.writer.commit();
this.taskState.setWorkingState(WorkUnitState.WorkingState.COMMITTED);
if (Metrics.isEnabled(this.taskState.getWorkunit())) {
updateByteMetrics();
}
}
}
 catch (IOException ioe) {
if (this.taskState.getWorkingState() != WorkUnitState.WorkingState.COMMITTED) {
LOG.error("Failed to commit data of task " + this.taskId,ioe);
}
}
 finally {
try {
this.writer.cleanup();
}
 catch (IOException ioe) {
LOG.error("The writer failed to cleanup for task " + taskId,ioe);
}
}
}
if (publisher != null) {
try {
publisher.cleanup();
}
 catch (Exception e) {
LOG.error("Failed to close the task publisher for task " + taskId,e);
}
}
if (rowChecker != null) {
try {
rowChecker.close();
}
 catch (IOException ioe) {
LOG.error("Failed to close the row quality checker for task " + taskId,ioe);
}
}
long endTime=System.currentTimeMillis();
this.taskState.setEndTime(endTime);
this.taskState.setTaskDuration(endTime - startTime);
this.taskStateTracker.onTaskCompletion(this);
}
}
