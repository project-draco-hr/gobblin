{
  long startTime=System.currentTimeMillis();
  this.taskState.setStartTime(startTime);
  RowLevelPolicyChecker rowChecker=null;
  boolean writerClosed=false;
  try {
    this.extractor=this.taskContext.getSource().getExtractor(this.taskState);
    if (this.extractor == null) {
      LOG.error("No extractor created for task " + this.taskId);
      return;
    }
    Object sourceSchema=this.extractor.getSchema();
    if (sourceSchema == null) {
      LOG.error("Not extracting data because no source schema available for task " + this.taskId);
      return;
    }
    boolean doConversion=!this.taskContext.getConverters().isEmpty();
    Converter converter=null;
    Object schemaForWriter=sourceSchema;
    if (doConversion) {
      converter=new MultiConverter(this.taskContext.getConverters());
      schemaForWriter=converter.convertSchema(sourceSchema,this.taskState);
    }
    rowChecker=buildRowLevelPolicyChecker(this.taskState);
    RowLevelPolicyCheckResults rowResults=new RowLevelPolicyCheckResults();
    this.writer=buildWriter(this.taskContext,schemaForWriter);
    this.taskState.setWorkingState(WorkUnitState.WorkingState.WORKING);
    this.taskStateTracker.registerNewTask(this);
    Object record;
    while ((record=this.extractor.readRecord()) != null) {
      if (doConversion) {
        record=converter.convertRecord(sourceSchema,record,this.taskState);
      }
      if (rowChecker.executePolicies(record,rowResults)) {
        this.writer.write(record);
      }
    }
    publishData(rowResults,schemaForWriter);
    this.writer.close();
    writerClosed=true;
    commitData();
  }
 catch (  Throwable t) {
    LOG.error(String.format("Task %s failed",this.taskId),t);
    this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
    this.taskState.setProp(ConfigurationKeys.TASK_FAILURE_EXCEPTION_KEY,t.toString());
  }
 finally {
    if (this.extractor != null) {
      try {
        this.extractor.close();
      }
 catch (      Exception ioe) {
        LOG.error("Failed to close the extractor for task " + taskId,ioe);
      }
    }
    if (rowChecker != null) {
      try {
        rowChecker.close();
      }
 catch (      IOException ioe) {
        LOG.error("Failed to close the row quality checker for task " + taskId,ioe);
      }
    }
    if (this.publisher != null) {
      try {
        this.publisher.cleanup();
      }
 catch (      Exception e) {
        LOG.error("Failed to close the task publisher for task " + taskId,e);
      }
    }
    if (this.writer != null) {
      if (!writerClosed) {
        try {
          this.writer.close();
        }
 catch (        IOException ioe) {
          LOG.error("Failed to close the writer for task " + taskId,ioe);
        }
      }
      try {
        this.writer.cleanup();
      }
 catch (      IOException ioe) {
        LOG.error("The writer failed to cleanup for task " + taskId,ioe);
      }
    }
    long endTime=System.currentTimeMillis();
    this.taskState.setEndTime(endTime);
    this.taskState.setTaskDuration(endTime - startTime);
    this.taskStateTracker.onTaskCompletion(this);
  }
}
