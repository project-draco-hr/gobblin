{
  long startTime=System.currentTimeMillis();
  this.taskState.setStartTime(startTime);
  this.taskStateTracker.registerNewTask(this);
  this.taskState.setWorkingState(WorkUnitState.WorkingState.RUNNING);
  this.forks.clear();
  Closer closer=Closer.create();
  try {
    List<Converter> converterList=this.taskContext.getConverters();
    boolean doConversion=!converterList.isEmpty();
    Converter converter=new MultiConverter(converterList);
    ForkOperator forkOperator=closer.register(this.taskContext.getForkOperator());
    forkOperator.init(this.taskState);
    int branches=forkOperator.getBranches(this.taskState);
    this.taskState.setProp(ConfigurationKeys.FORK_BRANCHES_KEY,branches);
    Extractor extractor=closer.register(new ExtractorDecorator(new SourceDecorator(this.taskContext.getSource(),this.jobId,LOG).getExtractor(this.taskState),this.taskId,LOG));
    Object sourceSchema=extractor.getSchema();
    if (doConversion) {
      sourceSchema=converter.convertSchema(sourceSchema,this.taskState);
    }
    List<Boolean> forkedSchemas=forkOperator.forkSchema(this.taskState,sourceSchema);
    if (forkedSchemas.size() != branches) {
      throw new ForkBranchMismatchException(String.format("Number of forked schemas [%d] is not equal to number of branches [%d]",forkedSchemas.size(),branches));
    }
    if (inMultipleBranches(forkedSchemas) && !(sourceSchema instanceof Copyable)) {
      throw new CopyNotSupportedException(sourceSchema + " is not copyable");
    }
    for (int i=0; i < branches; i++) {
      if (forkedSchemas.get(i)) {
        Fork fork=closer.register(new Fork(this.taskContext,this.taskState,branches > 1 ? ((Copyable)sourceSchema).copy() : sourceSchema,branches,i));
        this.forks.add(Optional.of(fork));
      }
 else {
        this.forks.add(Optional.<Fork>absent());
      }
    }
    RowLevelPolicyChecker rowChecker=closer.register(this.taskContext.getRowLevelPolicyChecker(this.taskState));
    RowLevelPolicyCheckResults rowResults=new RowLevelPolicyCheckResults();
    long pullLimit=this.taskState.getPropAsLong(ConfigurationKeys.EXTRACT_PULL_LIMIT,0);
    long recordsPulled=0;
    Object record=null;
    while ((pullLimit <= 0 || recordsPulled < pullLimit) && (record=extractor.readRecord(record)) != null) {
      recordsPulled++;
      Object convertedRecord=doConversion ? converter.convertRecord(sourceSchema,record,this.taskState) : record;
      if (convertedRecord != null && rowChecker.executePolicies(convertedRecord,rowResults)) {
        List<Boolean> forkedRecords=forkOperator.forkDataRecord(this.taskState,convertedRecord);
        if (forkedRecords.size() != branches) {
          throw new ForkBranchMismatchException(String.format("Number of forked data records [%d] is not equal to number of branches [%d]",forkedRecords.size(),branches));
        }
        if (inMultipleBranches(forkedRecords) && !(convertedRecord instanceof Copyable)) {
          throw new CopyNotSupportedException(convertedRecord + " is not copyable");
        }
        for (int i=0; i < branches; i++) {
          if (this.forks.get(i).isPresent() && forkedRecords.get(i)) {
            this.forks.get(i).get().processRecord(branches > 1 ? ((Copyable)convertedRecord).copy() : convertedRecord);
          }
        }
      }
    }
    LOG.info("Extracted " + recordsPulled + " data records");
    LOG.info("Row quality checker finished with results: " + rowResults.getResults());
    for (    Optional<Fork> fork : this.forks) {
      if (fork.isPresent()) {
        fork.get().commit(recordsPulled,extractor.getExpectedRecordCount(),pullLimit);
      }
    }
  }
 catch (  Throwable t) {
    LOG.error(String.format("Task %s failed",this.taskId),t);
    this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
    this.taskState.setProp(ConfigurationKeys.TASK_FAILURE_EXCEPTION_KEY,t.toString());
  }
 finally {
    try {
      closer.close();
    }
 catch (    Throwable t) {
      LOG.error("Failed to close all open resources",t);
    }
    long endTime=System.currentTimeMillis();
    this.taskState.setEndTime(endTime);
    this.taskState.setTaskDuration(endTime - startTime);
    this.taskStateTracker.onTaskCompletion(this);
  }
}
