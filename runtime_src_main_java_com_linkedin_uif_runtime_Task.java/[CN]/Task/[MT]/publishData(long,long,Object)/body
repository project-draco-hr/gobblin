{
  if (pullLimit > 0) {
    this.taskState.setProp(ConfigurationKeys.EXTRACTOR_ROWS_EXPECTED,recordsPulled);
  }
 else {
    this.taskState.setProp(ConfigurationKeys.EXTRACTOR_ROWS_EXPECTED,this.extractor.getExpectedRecordCount());
  }
  this.taskState.setProp(ConfigurationKeys.WRITER_ROWS_WRITTEN,this.writer.recordsWritten());
  this.taskState.setProp(ConfigurationKeys.EXTRACT_SCHEMA,schemaForWriter.toString());
  TaskLevelPolicyChecker policyChecker=buildTaskLevelPolicyChecker(this.taskState);
  TaskLevelPolicyCheckResults taskResults=policyChecker.executePolicies();
  this.publisher=buildTaskPublisher(this.taskState,taskResults);
switch (this.publisher.canPublish()) {
case SUCCESS:
    this.shouldCommit=true;
  this.taskState.setWorkingState(WorkUnitState.WorkingState.SUCCESSFUL);
break;
case CLEANUP_FAIL:
LOG.error("Cleanup failed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
case POLICY_TESTS_FAIL:
LOG.error("Not all quality checking passed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
case COMPONENTS_NOT_FINISHED:
LOG.error("Not all components completed for task " + this.taskId);
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
default :
this.taskState.setWorkingState(WorkUnitState.WorkingState.FAILED);
break;
}
}
