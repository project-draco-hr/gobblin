{
  HashMap<Long,Long> intervalMap=new HashMap<Long,Long>();
  final SimpleDateFormat inputFormat=new SimpleDateFormat(INPUTFORMAT);
  if (partitionInterval < 1) {
    partitionInterval=1;
  }
  final Calendar calendar=Calendar.getInstance();
  Date nextTime;
  Date lowWatermarkDate=this.extractFromTimestamp(Long.toString(lowWatermarkValue));
  Date highWatermarkDate=this.extractFromTimestamp(Long.toString(highWatermarkValue));
  final long lowWatermark=lowWatermarkDate.getTime();
  final long highWatermark=highWatermarkDate.getTime();
  long interval=this.getInterval(highWatermark - lowWatermark,partitionInterval,maxIntervals) + 1;
  LOG.info("Recalculated partition interval:" + interval + " hours");
  if (interval == 0) {
    return intervalMap;
  }
  Date startTime=new Date(lowWatermark);
  Date endTime=new Date(highWatermark);
  LOG.debug("Sart time:" + startTime + "; End time:"+ endTime);
  long lwm;
  long hwm;
  while (startTime.getTime() <= endTime.getTime()) {
    lwm=Long.parseLong(inputFormat.format(startTime));
    calendar.setTime(startTime);
    calendar.add(Calendar.HOUR,(int)(interval - 1));
    nextTime=calendar.getTime();
    hwm=Long.parseLong(inputFormat.format(nextTime.getTime() <= endTime.getTime() ? nextTime : endTime));
    intervalMap.put(lwm,hwm);
    LOG.debug("Partition - low:" + lwm + "; high:"+ hwm);
    calendar.add(Calendar.SECOND,deltaForNextWatermark);
    startTime=calendar.getTime();
  }
  return intervalMap;
}
