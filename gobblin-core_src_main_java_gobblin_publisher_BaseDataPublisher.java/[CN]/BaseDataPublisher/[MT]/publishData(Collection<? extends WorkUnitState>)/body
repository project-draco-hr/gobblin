{
  Set<Path> writerOutputPathsMoved=Sets.newHashSet();
  for (  WorkUnitState workUnitState : states) {
    for (int branchId=0; branchId < this.numBranches; branchId++) {
      ParallelRunner parallelRunner=this.getParallelRunner(this.fss.get(branchId));
      Path writerOutputDir=WriterUtils.getWriterOutputDir(workUnitState,this.numBranches,branchId);
      if (!this.fss.get(branchId).exists(writerOutputDir)) {
        LOG.warn("WorkUnit " + workUnitState.getId() + " produced no data");
        workUnitState.setWorkingState(WorkUnitState.WorkingState.COMMITTED);
        break;
      }
      Path publisherOutputDir=WriterUtils.getDataPublisherFinalDir(workUnitState,this.numBranches,branchId);
      if (writerOutputPathsMoved.contains(writerOutputDir)) {
        continue;
      }
      if (this.fss.get(branchId).exists(publisherOutputDir)) {
        boolean replaceFinalOutputDir=this.getState().getPropAsBoolean(ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR,this.numBranches,branchId));
        if (!replaceFinalOutputDir) {
          addWriterOutputToExistingDir(writerOutputDir,publisherOutputDir,workUnitState,branchId,parallelRunner);
          writerOutputPathsMoved.add(writerOutputDir);
          continue;
        }
        this.fss.get(branchId).delete(publisherOutputDir,true);
      }
 else {
        this.fss.get(branchId).mkdirs(publisherOutputDir.getParent());
      }
      LOG.info(String.format("Moving %s to %s",writerOutputDir,publisherOutputDir));
      parallelRunner.renamePath(writerOutputDir,publisherOutputDir);
      writerOutputPathsMoved.add(writerOutputDir);
    }
    workUnitState.setWorkingState(WorkUnitState.WorkingState.COMMITTED);
  }
}
