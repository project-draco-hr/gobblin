{
  HashMap<Long,Long> defaultPartition=new HashMap<Long,Long>();
  if (!isWatermarkExists()) {
    defaultPartition.put(ConfigurationKeys.DEFAULT_WATERMARK_VALUE,ConfigurationKeys.DEFAULT_WATERMARK_VALUE);
    LOG.info("Watermark column or type not found - Default partition with low watermark and high watermark as " + ConfigurationKeys.DEFAULT_WATERMARK_VALUE);
    return defaultPartition;
  }
  ExtractType extractType=ExtractType.valueOf(this.state.getProp(ConfigurationKeys.SOURCE_EXTRACT_TYPE).toUpperCase());
  WatermarkType watermarkType=WatermarkType.valueOf(state.getProp(ConfigurationKeys.SOURCE_WATERMARK_TYPE).toUpperCase());
  int interval=this.getUpdatedInterval(Utils.getAsInt(this.state.getProp(ConfigurationKeys.SOURCE_PARTITION_INTERVAL)),extractType,watermarkType);
  int maxPartitions=ConfigurationKeys.DEFAULT_MAX_NUMBER_OF_PARTITIONS;
  WatermarkPredicate watermark=new WatermarkPredicate(null,watermarkType);
  int deltaForNextWatermark=watermark.getDeltaNumForNextWatermark();
  long lowWatermark=this.getLowWatermark(extractType,watermarkType,previousWatermark,deltaForNextWatermark);
  long highWatermark=this.getHighWatermark(extractType,watermarkType);
  if (lowWatermark == ConfigurationKeys.DEFAULT_WATERMARK_VALUE || highWatermark == ConfigurationKeys.DEFAULT_WATERMARK_VALUE) {
    LOG.info("Low watermark or high water mark is not found. Hence cannot generate partitions - Default partition with low watermark: " + lowWatermark + " and high watermark: "+ highWatermark);
    defaultPartition.put(lowWatermark,highWatermark);
    return defaultPartition;
  }
  LOG.info("Get partitions with low watermark:" + lowWatermark + " ;high watermark:"+ highWatermark+ " ;partition interval in hours:"+ interval+ " ;Maximum number of allowed partitions:"+ maxPartitions);
  return watermark.getPartitions(lowWatermark,highWatermark,interval,maxPartitions);
}
