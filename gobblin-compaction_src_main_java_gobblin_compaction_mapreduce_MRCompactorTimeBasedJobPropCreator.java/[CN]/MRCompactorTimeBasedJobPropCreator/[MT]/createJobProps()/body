{
  List<State> allJobProps=Lists.newArrayList();
  if (!fs.exists(this.topicInputDir)) {
    LOG.warn("Input folder " + this.topicInputDir + " does not exist. Skipping topic "+ topic);
    return allJobProps;
  }
  String folderStructure=getFolderStructure();
  for (  FileStatus status : this.fs.globStatus(new Path(this.topicInputDir,folderStructure))) {
    DateTime folderTime=null;
    try {
      folderTime=getFolderTime(status.getPath());
    }
 catch (    RuntimeException e) {
      LOG.warn(status.getPath() + " is not a valid folder. Will be skipped.");
      continue;
    }
    Path jobOutputDir=new Path(this.topicOutputDir,folderTime.toString(this.timeFormatter));
    Path jobTmpDir=new Path(this.topicTmpDir,folderTime.toString(this.timeFormatter));
    if (folderWithinAllowedPeriod(status.getPath(),folderTime)) {
      if (!folderAlreadyCompacted(jobOutputDir)) {
        allJobProps.add(createJobProps(status.getPath(),jobOutputDir,jobTmpDir,this.deduplicate,folderTime.toString(this.timeFormatter)));
      }
 else {
        List<Path> newDataFiles=getNewDataInFolder(status.getPath(),jobOutputDir);
        if (newDataFiles.isEmpty()) {
          LOG.info(String.format("Folder %s already compacted. Skipping",jobOutputDir));
        }
 else {
          Path jobOutputLateDir=new Path(this.topicOutputBaseDir,new Path(this.state.getProp(MRCompactor.COMPACTION_DEST_LATE_SUBDIR,MRCompactor.DEFAULT_COMPACTION_DEST_LATE_SUBDIR),folderTime.toString(this.timeFormatter)));
          allJobProps.add(createJobPropsForLateData(status.getPath(),jobOutputDir,jobOutputLateDir,jobTmpDir,newDataFiles));
        }
      }
    }
  }
  return allJobProps;
}
