{
  validateInput(state);
  try (Connection conn=createConnection(state)){
    JobCommitPolicy jobCommitPolicy=JobCommitPolicy.getCommitPolicy(state);
    boolean isSkipStaging=!JobCommitPolicy.COMMIT_ON_FULL_SUCCESS.equals(JobCommitPolicy.getCommitPolicy(state));
    if (isSkipStaging) {
      LOG.info("Writer will write directly to destination table as JobCommitPolicy is " + jobCommitPolicy);
    }
    int branches=state.getPropAsInt(ConfigurationKeys.FORK_BRANCHES_KEY,1);
    Map<Integer,Queue<String>> stagingTables=Maps.newHashMap();
    for (int branchId=0; branchId < branches; branchId++) {
      final String publishTable=getProp(state,ConfigurationKeys.JDBC_PUBLISHER_FINAL_TABLE_NAME,branches,branchId);
      for (int i=0; i < workUnits.size(); i++) {
        Queue<String> stagingTablesForBranch=stagingTables.get(branchId);
        if (stagingTablesForBranch == null) {
          stagingTablesForBranch=Lists.newLinkedList();
          stagingTables.put(branchId,stagingTablesForBranch);
        }
        if (isSkipStaging) {
          LOG.info("User chose to skip staing table on branch " + branchId);
          stagingTablesForBranch.add(publishTable);
          if (getPropAsBoolean(state,ConfigurationKeys.JDBC_PUBLISHER_REPLACE_FINAL_TABLE,branches,branchId)) {
            LOG.info("User chose to replace final table " + publishTable + " on branch "+ branchId);
            truncate(conn,publishTable);
          }
          continue;
        }
        String stagingTableKey=ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.WRITER_STAGING_TABLE,branches,1);
        String stagingTable=state.getProp(stagingTableKey);
        if (!StringUtils.isEmpty(stagingTable)) {
          LOG.info("Staging table for branch " + branchId + " from user: "+ stagingTable);
          if (!isEmpty(conn,stagingTable)) {
            LOG.error("Staging table " + stagingTable + " is not empty. Failing.");
            throw new IllegalArgumentException("Staging table " + stagingTable + " should be empty.");
          }
          stagingTablesForBranch.add(stagingTable);
          passedStagingTables.add(stagingTable);
          continue;
        }
        LOG.info("Staging table has not been passed from user for branch " + branchId + ". Creating.");
        stagingTable=createStagingTable(conn,state,branches,branchId);
        stagingTablesForBranch.add(stagingTable);
        createdStagingTables.add(stagingTable);
        LOG.info("Staging table " + stagingTable + " has been created for branchId "+ branchId);
      }
    }
    for (    WorkUnit wu : workUnits) {
      for (int branchId=0; branchId < branches; branchId++) {
        Queue<String> stagingTablesForBranch=Objects.requireNonNull(stagingTables.get(branchId));
        String stagingTableKey=ForkOperatorUtils.getPropertyNameForBranch(ConfigurationKeys.WRITER_STAGING_TABLE,branches,1);
        String stagingTable=stagingTablesForBranch.remove();
        LOG.info("Update workunit state " + stagingTableKey + " , "+ stagingTable);
        wu.setProp(stagingTableKey,stagingTable);
      }
    }
  }
 catch (  SQLException e) {
    throw new RuntimeException("Failed with SQL",e);
  }
}
